# Ответы на задание к занятию "3.1. Работа в терминале, лекция 1"
5. Какие ресурсы выделены по-умолчанию? </br>
Vagrant создал виртуальную машину со следующими параметрами: </br>
CPU 2 ядра</br>
RAM 1024 MB</br>
VRAM 4 MB</br>
HDD SATA 64 GB</br>
Net Intel PRO/1000 MT (NAT)</br>
Audio отключено</br>
USB отключено</br>

6. Как добавить оперативной памяти или ресурсов процессора виртуальной машине? </br>
Добавить в Vagrantfile:</br>
_config.vm.provider "virtualbox" do |vb|</br>
     vb.memory = "2048"</br>
     vb.cpus = 4</br>
end_</br>
  

8. Какой переменной можно задать длину журнала history, и на какой строчке manual это описывается?   
   Задается переменной HISTSIZE, строка 685</br>

   Что делает директива ignoreboth в bash?</br>
   HISTCONTROL=ignoreboth это комбинация директив ignorespace и ignoredups, она указывает bash не сохранять в истории команды, начинающиеся с символа пробела и ранее встречавшиеся команды (дубли).

9. В каких сценариях использования применимы скобки {} и на какой строчке man bash это описано?</br>
Начиная со строки 863 подстановка фигурных скобок позволяет из одного шаблона получить множество строк. Например, шаблон a{d,c,b}e раскроется в ade ace abe. Такую подстановку удобно использовать, наприер, для генерации имен файлов или каталогов.

10. С учётом ответа на предыдущий вопрос, как создать однократным вызовом touch 100000 файлов? Получится ли аналогичным образом создать 300000? Если нет, то почему?</br>
_touch {1..100000}_</br>
300000 файлов таким образом создать не получится, так как будет превышен лимит на длину списка аргументов. bash создаст слишком длинную строку (команда + аргументы). Вместо этого нужно использовать циклы.
Длина списка аргументов ограничена в ядре Linux и зависит от величины стека, длины каждого аргумента, а также объема памяти, занимаемого окружением (внутренние параметры ARG_MAX, MAX_ARG_STRLEN, MAX_ARG_STRINGS). Статья (https://unix.stackexchange.com/questions/120642/what-defines-the-maximum-size-for-a-command-single-argument/120842#120842) проливает некоторый свет на этот вопрос.

11. Что делает конструкция [[ -d /tmp ]]?</br>
Конструкция [[ _выражение_ ]] применяется для проверки истинности или ложности _выражения_.
В данном случае проверяется существование каталога /tmp и то, что он является именно каталогом, а не файлом.</br>
После _[[ -d /tmp ]]_ </br>
_echo $?_ возвращает 0 (true, код успешного завершения предыдущей команды)</br>
а после, например, _[[ -d /123 ]]_,</br>
_echo $?_ возвращает 1 (false, проверка не пройдена)</br>
[[ _выражение_ ]] это более современная замена команды _test_, обе возвращают 0, если _выражение_ истинно и 1, если ложно.

12.
_mkdir /tmp/new_path_directory</br>
touch /tmp/new_path_directory/bash</br>
chmod +x /tmp/new_path_directory/bash</br>
export PATH=/tmp/new_path_directory/:$PATH_</br>

или можно так

_mkdir /tmp/new_path_directory</br>
ln -s /bin/bash /tmp/new_path_directory/bash</br>
export PATH=/tmp/new_path_directory/:$PATH_

13. Чем отличается планирование команд с помощью batch и at?</br>
at назначет одноразовое задание на определенное время, а batch выполнит задание (также один раз), когда загрузка системы опустится ниже определенного предела (load average ниже 1.5 для современных ядер или этот уровень можно задать с помощью atd -l)




# Ответы на задание к занятию "3.2. Работа в терминале, лекция 2"
1. Какого типа команда cd?</br> 
Это внутренняя (встроенная) команда bash, т.е. она является неотъемлимой частью самого bash как командной оболочки.
Основная задача любой командной оболочки - запуск других программ, а для этого необходимо указывать абсолютный путь до исполняемого файла в файловой системе.
cd значительно облегчает этот процесс, т.к. фактически указывает bash, где в первую очередь искать требуемый файл, а также задает каталог по-умолчанию для других программ
и в конечном итоге позволяет писать более короткие команды. Поэтому логично сделать такую команду частью функционала самой оболочки. Трудно представить cd в виде внешней команды 
(исполняемого файла), т.к. это поставило бы базовую функциональность bash в зависимость от наличия этого файла на диске, сделало bash несамодостаточной программой.
Можно представить себе неиерархическую файловую систему, где каждый файл однозначно определяется только неким уникальным буквенно-цифровым идентификатором, а не абсолютным путем.
В такой системе cd был бы не нужен, но навигация, поиск файлов, запуск других программ потребовал бы совершенно иного подхода.

2. Альтернатива без pipe команде _grep <some_string> <some_file> | wc -l_ это _grep -с <some_string> <some_file>_, которая посчитает и выведет на экран количество найденных строк в файле.

3. В Ubuntu 20.04 процесс с PID 1 - это systemd. _ps_ это покажет.

4. Как будет выглядеть команда, которая перенаправит вывод stderr ls на другую сессию терминала?</br>
Если у нас 2 сессии (pts/0 и pts/1) и мы работаем в сессии 0, то так - _ls -l 2>/dev/pts/1_

5. Получится. Вот искусственный, но работающий пример - _cat < file1.txt > file2.txt_

6. Получится, если там открыта сессия (выполнен логин). Например, _echo text123 > /dev/tty2_. Для просмотра данных нужно переключиться из GUI на этот TTY клавишами Ctrl+Alt+2 или можно
прочитать /dev/vcs2 - символьное устройство для виртуальных терминалов, соответствующее /dev/tty2. Требуются права root.

7. Будет запущен новый экземпляр bash, у которого будет создан файловый дескрипор 5, указывающий на stdout. _echo netology > /proc/$$/fd/5_ выведет слово netology в терминале. Это происходит потому, что файловый дескриптор 5 указывает на stdout.

8. Получится. Например, так _bash 5>&1 1>&2 2>&5_. Здесь будет запущен bash, у которого stdout и stderr поменяны местами через промежуточный файловый дескрипор 5.

9. Команда _cat /proc/$$/environ_ покажет переменные окружения для текущего процесса. Их также можно получить командой _ps e -p $$_

10. _man proc_ говорит о том, что _/proc/\<PID\>/cmdline_ это доступный только для чтения файл, в котором содержится полная командная строка процесса. Для зомби-процессов это файл пустой. Аргументы командной строки
отображаются как набор строк, разделенных нулевым символом '\0', с '\0' в конце. А _/proc/\<PID\>/exe_ - это символическая ссылка на саму выполняющуюся программу. Можно использовать _/proc/\<PID\>/exe_ для запуска еще одной
копии процесса.

11. Я сделал так. _more /proc/cpuinfo | grep -i sse_, и нашел в выводе sse4_2, т.е. мой процессор поддерживает SSE 4.2 

12. По-умолчанию, для запуска программ на удаленной машине через ssh PTY не выделяется для удаленной сессии. Во-первых, программы на удаленной машине будут всегда выполнятся в неинтерактивном режиме, что считается более
безопасным способом. Во-вторых, это позволяет передавать бинарные данные, не беспокоясь о наличии в них ESC-последовательностей, которые могли бы быть перехвачены и интерпретированы удаленным shell'ом.
Изменить поведение можно с помощью ключа -t (принудительное выделение PTY).

13. Запускаем процесс, например, top.</br>
Ctrl-Z - останавливаем его</br>
jobs -l - запоминаем PID</br>
disown \<PID\> - отсоединяем процесс от текущего PTY</br>
reptyr \<PID\> - присоединяем процесс к другому PTY</br>

14. Команда _tee_ создает Т-образное разветвление, она читает данные из stdin и записывает их в stdout и в указанный файл. Конструкция _echo string | sudo tee /root/new_file_ будет работать, так как привилегии для процесса tee
будут повышены с помощью sudo, при этом само sudo не выполняет перенаправление вывода, поэтому для конструкции _sudo echo string_ повышения привилегий не происходит.

