# Ответы на задание к занятию "3.1. Работа в терминале, лекция 1"
5. Какие ресурсы выделены по-умолчанию? </br>
Vagrant создал виртуальную машину со следующими параметрами: </br>
CPU 2 ядра</br>
RAM 1024 MB</br>
VRAM 4 MB</br>
HDD SATA 64 GB</br>
Net Intel PRO/1000 MT (NAT)</br>
Audio отключено</br>
USB отключено</br>

6. Как добавить оперативной памяти или ресурсов процессора виртуальной машине? </br>
Добавить в Vagrantfile:</br>
_config.vm.provider "virtualbox" do |vb|</br>
     vb.memory = "2048"</br>
     vb.cpus = 4</br>
end_</br>

.

8. Какой переменной можно задать длину журнала history, и на какой строчке manual это описывается?   
   Задается переменной HISTSIZE, строка 685</br>

   Что делает директива ignoreboth в bash?</br>
   HISTCONTROL=ignoreboth это комбинация директив ignorespace и ignoredups, она указывает bash не сохранять в истории команды, начинающиеся с символа пробела и ранее встречавшиеся команды (дубли).

9. В каких сценариях использования применимы скобки {} и на какой строчке man bash это описано?</br>
Начиная со строки 863 подстановка фигурных скобок позволяет из одного шаблона получить множество строк. Например, шаблон a{d,c,b}e раскроется в ade ace abe. Такую подстановку удобно использовать, наприер, для генерации имен файлов или каталогов.

10. С учётом ответа на предыдущий вопрос, как создать однократным вызовом touch 100000 файлов? Получится ли аналогичным образом создать 300000? Если нет, то почему?</br>
_touch {1..100000}_</br>
300000 файлов таким образом создать не получится, так как будет превышен лимит на длину списка аргументов. bash создаст слишком длинную строку (команда + аргументы). Вместо этого нужно использовать циклы.
Длина списка аргументов ограничена в ядре Linux и зависит от величины стека, длины каждого аргумента, а также объема памяти, занимаемого окружением (внутренние параметры ARG_MAX, MAX_ARG_STRLEN, MAX_ARG_STRINGS). Статья (https://unix.stackexchange.com/questions/120642/what-defines-the-maximum-size-for-a-command-single-argument/120842#120842) проливает некоторый свет на этот вопрос.

11. Что делает конструкция [[ -d /tmp ]]?</br>
Конструкция [[ _выражение_ ]] применяется для проверки истинности или ложности _выражения_.
В данном случае проверяется существование каталога /tmp и то, что он является именно каталогом, а не файлом.</br>
После _[[ -d /tmp ]]_ </br>
_echo $?_ возвращает 0 (true, код успешного завершения предыдущей команды)</br>
а после, например, _[[ -d /123 ]]_,</br>
_echo $?_ возвращает 1 (false, проверка не пройдена)</br>
[[ _выражение_ ]] это более современная замена команды _test_, обе возвращают 0, если _выражение_ истинно и 1, если ложно.

12.
_mkdir /tmp/new_path_directory</br>
touch /tmp/new_path_directory/bash</br>
chmod +x /tmp/new_path_directory/bash</br>
export PATH=/tmp/new_path_directory/:$PATH_</br>

или можно так

_mkdir /tmp/new_path_directory</br>
ln -s /bin/bash /tmp/new_path_directory/bash</br>
export PATH=/tmp/new_path_directory/:$PATH_

13. Чем отличается планирование команд с помощью batch и at?</br>
at назначет одноразовое задание на определенное время, а batch выполнит задание (также один раз), когда загрузка системы опустится ниже определенного предела (load average ниже 1.5 для современных ядер или этот уровень можно задать с помощью atd -l)




# Ответы на задание к занятию "3.2. Работа в терминале, лекция 2"
1. Какого типа команда cd?</br> 
Это внутренняя (встроенная) команда bash, т.е. она является неотъемлимой частью самого bash как командной оболочки.
Основная задача любой командной оболочки - запуск других программ, а для этого необходимо указывать абсолютный путь до исполняемого файла в файловой системе.
cd значительно облегчает этот процесс, т.к. фактически указывает bash, где в первую очередь искать требуемый файл, а также задает каталог по-умолчанию для других программ
и в конечном итоге позволяет писать более короткие команды. Поэтому логично сделать такую команду частью функционала самой оболочки. Трудно представить cd в виде внешней команды 
(исполняемого файла), т.к. это поставило бы базовую функциональность bash в зависимость от наличия этого файла на диске, сделало bash несамодостаточной программой.
Можно представить себе неиерархическую файловую систему, где каждый файл однозначно определяется только неким уникальным буквенно-цифровым идентификатором, а не абсолютным путем.
В такой системе cd был бы не нужен, но навигация, поиск файлов, запуск других программ потребовал бы совершенно иного подхода.

2. Альтернатива без pipe команде _grep <some_string> <some_file> | wc -l_ это _grep -с <some_string> <some_file>_, которая посчитает и выведет на экран количество найденных строк в файле.

3. В Ubuntu 20.04 процесс с PID 1 - это systemd. _ps_ это покажет.

4. Как будет выглядеть команда, которая перенаправит вывод stderr ls на другую сессию терминала?</br>
Если у нас 2 сессии (pts/0 и pts/1) и мы работаем в сессии 0, то так - _ls -l 2>/dev/pts/1_

5. Получится. Вот искусственный, но работающий пример - _cat < file1.txt > file2.txt_

6. Получится, если там открыта сессия (выполнен логин). Например, _echo text123 > /dev/tty2_. Для просмотра данных нужно переключиться из GUI на этот TTY клавишами Ctrl+Alt+2 или можно
прочитать /dev/vcs2 - символьное устройство для виртуальных терминалов, соответствующее /dev/tty2. Требуются права root.

7. Будет запущен новый экземпляр bash, у которого будет создан файловый дескрипор 5, указывающий на stdout. _echo netology > /proc/$$/fd/5_ выведет слово netology в терминале. Это происходит потому, что файловый дескриптор 5 указывает на stdout.

8. Получится. Например, так _bash 5>&1 1>&2 2>&5_. Здесь будет запущен bash, у которого stdout и stderr поменяны местами через промежуточный файловый дескрипор 5.

9. Команда _cat /proc/$$/environ_ покажет переменные окружения для текущего процесса. Их также можно получить командой _ps e -p $$_

10. _man proc_ говорит о том, что _/proc/\<PID\>/cmdline_ это доступный только для чтения файл, в котором содержится полная командная строка процесса. Для зомби-процессов это файл пустой. Аргументы командной строки
отображаются как набор строк, разделенных нулевым символом '\0', с '\0' в конце. А _/proc/\<PID\>/exe_ - это символическая ссылка на саму выполняющуюся программу. Можно использовать _/proc/\<PID\>/exe_ для запуска еще одной
копии процесса.

11. Я сделал так. _more /proc/cpuinfo | grep -i sse_, и нашел в выводе sse4_2, т.е. мой процессор поддерживает SSE 4.2 

12. По-умолчанию, для запуска программ на удаленной машине через ssh PTY не выделяется для удаленной сессии. Во-первых, программы на удаленной машине будут всегда выполнятся в неинтерактивном режиме, что считается более
безопасным способом. Во-вторых, это позволяет передавать бинарные данные, не беспокоясь о наличии в них ESC-последовательностей, которые могли бы быть перехвачены и интерпретированы удаленным shell'ом.
Изменить поведение можно с помощью ключа -t (принудительное выделение PTY).

13. Запускаем процесс, например, top.</br>
Ctrl-Z - останавливаем его</br>
jobs -l - запоминаем PID</br>
disown \<PID\> - отсоединяем процесс от текущего PTY</br>
reptyr \<PID\> - присоединяем процесс к другому PTY</br>

14. Команда _tee_ создает Т-образное разветвление, она читает данные из stdin и записывает их в stdout и в указанный файл. Конструкция _echo string | sudo tee /root/new_file_ будет работать, так как привилегии для процесса tee
будут повышены с помощью sudo, при этом само sudo не выполняет перенаправление вывода, поэтому для конструкции _sudo echo string_ повышения привилегий не происходит.



# Ответы на задание к занятию "3.3. Операционные системы, лекция 1"
1. Какой системный вызов делает команда cd?</br>
Я сделал таким образом:</br>
_strace /bin/bash -c 'cd /tmp' 2>strace.log</br>
grep '/tmp' strace.log_</br>
И получил следующее:</br>
_execve("/bin/bash", ["/bin/bash", "-c", "cd /tmp"], 0x7ffce782af70 /* 23 vars */) = 0</br>
stat("/tmp", {st_mode=S_IFDIR|S_ISVTX|0777, st_size=4096, ...}) = 0</br>
chdir("/tmp")                           = 0_</br>
Первая строка в самом начале лога и относится к команде запуска bash, а вот ближе к концу лога мы видим 2 системных вызова:
stat() - получает файловые атрибуты по inode и собственно интрересующий нас вызов chdir(), выполняющий смену рабочего каталога.
Таким образом у команды cd в ядре есть соответствущий ей системный вызов chdir(), принимающий единственный аргумент - путь к требуемуму каталогу.

2. Порядок действий таков.</br>
Соберем логи strace на разные команды</br>
_strace file /dev/tty 2>strace1.log</br>
strace file /dev/sda 2>strace2.log</br>
strace file /bin/bash 2>strace3.log_</br>
Раз команда file ищет в своей базе данных, значит она должна ее предварительно открыть. Поищем системные вызовы для открытия файлов, например, open() в логах.</br>
_grep open strace1.log</br>
grep open strace2.log</br>
grep open strace3.log_</br>
И сравним. В принципе, там один и тот же набор: </br>
_openat(AT_FDCWD, "/etc/ld.so.cache", O_RDONLY|O_CLOEXEC) = 3</br>
openat(AT_FDCWD, "/lib/x86_64-linux-gnu/libmagic.so.1", O_RDONLY|O_CLOEXEC) = 3</br>
openat(AT_FDCWD, "/lib/x86_64-linux-gnu/libc.so.6", O_RDONLY|O_CLOEXEC) = 3</br>
openat(AT_FDCWD, "/lib/x86_64-linux-gnu/liblzma.so.5", O_RDONLY|O_CLOEXEC) = 3</br>
openat(AT_FDCWD, "/lib/x86_64-linux-gnu/libbz2.so.1.0", O_RDONLY|O_CLOEXEC) = 3</br>
openat(AT_FDCWD, "/lib/x86_64-linux-gnu/libz.so.1", O_RDONLY|O_CLOEXEC) = 3</br>
openat(AT_FDCWD, "/lib/x86_64-linux-gnu/libpthread.so.0", O_RDONLY|O_CLOEXEC) = 3</br>
openat(AT_FDCWD, "/usr/lib/locale/locale-archive", O_RDONLY|O_CLOEXEC) = 3</br>
openat(AT_FDCWD, "/etc/magic.mgc", O_RDONLY) = -1 ENOENT (No such file or directory)</br>
openat(AT_FDCWD, "/etc/magic", O_RDONLY) = 3</br>
openat(AT_FDCWD, "/usr/share/misc/magic.mgc", O_RDONLY) = 3</br>
openat(AT_FDCWD, "/usr/lib/x86_64-linux-gnu/gconv/gconv-modules.cache", O_RDONLY) = 3_</br>

Видим файлы кеша, файлы библиотек, локаль, и некие файлы magic</br>
_/etc/magic.mgc_ - файл не найден</br>
_/etc/magic_ - файл пуст, но в нем есть комментарий, говорящий о том, что в этот файл можно добавить локальную для этой систмемы информацию для file. Формат записей можно узнать в man 5 magic.</br>
_/usr/share/misc/magic.mgc_ - это ссылка на /usr/lib/file/magic.mgc - это и есть искомая стандартная база для file.</br>

3. Зная PID процесса, нужно найти файловый дескриптор удаленного файла. Пример:</br>
_lsof -p 1566_</br>

COMMAND  PID    USER   FD   TYPE DEVICE SIZE/OFF    NODE NAME</br>
ping    1566 vagrant    1w   REG  253,0   185902 1312140 /home/vagrant/ping (deleted)</br>

У удаленного файла дескриптор 1 (stdout).</br>

Далее можно обнулить файл одной из следующих команд:</br>

_: > /proc/1566/fd/1</br>
echo -n > /proc/1566/fd/1</br>
truncate -s0 /proc/1566/fd/1_</br>

Т.к. процесс продолжает исполняться, то можно эти команды добавить в cron для того, чтоб продолжать обнулять файл.

4. Зомби-процесс - это завершившийся процесс, родитель которого по какой-то причине не выполнил процедуру обработки информации, оставшейся от дочернего процесса (код завершения) с помощью вызова wait().
Так как процесс уже завершился, то аппаратные ресурсы (CPU, RAM, IO) он не потребляет. Однако ему все еще выделен какой-то PID, для хранения которого все таки требуется небольшое количество памяти. 
Ну и так как общее количество PID в системе ограничено, то большое количество зомби-процессов может теоретически привести к исчерпанию PID. В этом основная опасность зомби-процессов.

5. _sudo opensnoop-bpfcc -d 1</br>
PID    COMM               FD ERR PATH</br>
882    vminfo              4   0 /var/run/utmp</br>
671    dbus-daemon        -1   2 /usr/local/share/dbus-1/system-services</br>
671    dbus-daemon        21   0 /usr/share/dbus-1/system-services</br>
671    dbus-daemon        -1   2 /lib/dbus-1/system-services</br>
671    dbus-daemon        21   0 /var/lib/snapd/dbus-1/system-services/</br>
679    irqbalance          6   0 /proc/interrupts</br>
679    irqbalance          6   0 /proc/stat</br>
679    irqbalance          6   0 /proc/irq/20/smp_affinity</br>
679    irqbalance          6   0 /proc/irq/0/smp_affinity</br>
679    irqbalance          6   0 /proc/irq/1/smp_affinity</br>
679    irqbalance          6   0 /proc/irq/8/smp_affinity</br>
679    irqbalance          6   0 /proc/irq/12/smp_affinity</br>
679    irqbalance          6   0 /proc/irq/14/smp_affinity</br>
679    irqbalance          6   0 /proc/irq/15/smp_affinity</br>
882    vminfo              4   0 /var/run/utmp</br>
671    dbus-daemon        -1   2 /usr/local/share/dbus-1/system-services</br>
671    dbus-daemon        21   0 /usr/share/dbus-1/system-services</br>
671    dbus-daemon        -1   2 /lib/dbus-1/system-services</br>
671    dbus-daemon        21   0 /var/lib/snapd/dbus-1/system-services/_</br>

6. С помощью strace аналогично вопросу 1 можно выяснить, что uname -a использует вызов uname(). </br>
В man 2 uname (строка 52) говорится: "Part of the utsname information is also accessible via /proc/sys/kernel/{ostype, hostname, osrelease, version, domainname}." 
Значит эту информацию можно найти в файлах osrelease и version в каталоге /proc/sys/kernel.

7. Через ; задается простая последовательность команд для bash, в которой все команды в любом случае будут последовательно выполнены. Выполнение последующих команд не зависит от результата выполнения предыдущих.
А && задает логическую (И) последовательность, когда следующая команда будет выполнена, только если предыдущая замершилась успешно с выходным кодом 0.
Применение set -e приводит к тому, что последовательность команд будет прервана немедленно при первой же неуспешной команде (с ненулевым кодом завершения). Значит, результат будет тот же, 
что и при использовании &&, следовательно нет смысла использовать &&. 

8. _set -euxo pipefail_ состоит из следующих опций:</br>

_-e_ - немедленно прервать работу, если команда завершилась с ненулевым кодом</br>
_-u_ - рассматривать неинициализированные переменные как ошибку и остановить скрипт</br>
_-x_ - выводить команды и их аргументы по мере исполнения</br>
_-o pipefail_ - вернуть в качестве кода завершения последовательности команд код последней неуспешной команды</br>

Такое сочетание параметров задает максимально безопасный режим исполнения скриптов, когда требуется, чтобы сбой в любой из команд скрипта приводил к его остановке. Также мы не теряем код завершения сбойной команды и знаем, какая именно команда сбоит, что идеально для отладки.

9. У меня при выполнении _ps -e -o stat_  получилась такая статистика:
_ps -e -o stat | grep -c D</br>
0</br>
ps -e -o stat | grep -c I</br>
56</br>
ps -e -o stat | grep -c R</br>
1</br>
ps -e -o stat | grep -c S</br>
71</br>
ps -e -o stat | grep -c T</br>
0</br>
ps -e -o stat | grep -c t</br>
0</br>
ps -e -o stat | grep -c W</br>
0</br>
ps -e -o stat | grep -c X</br>
0</br>
ps -e -o stat | grep -c Z</br>
0_</br>

Наиболее часто встречающийся статус - S - непрерываемый сон (процесс ожидает событие, чтобы завершиться).

Дополнительные символы в статусе означают:</br>
< - у процесса повышенный приоритет</br>
N - у процесса пониженный приоритет</br>
L - у процесса есть заблокированные страницы в памяти</br>
s - признак основного процесса сеанса</br>
l - многопоточный процесс (несколько тредов)</br>
_+_ - находится в foreground process group - группа процессов, чей ID равен ID группы текущего терминала</br>
